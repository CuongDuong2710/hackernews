1. Sử dụng prevState có hai cách

_ Một là khai báo một biến riêng lưu lại

handleOpenActions () {
    let openContextMenu = this.state.openContextMenu // khai báo riêng
    this.setState({
      openContextMenu: !openContextMenu
    })
}
  
_ Hai là dùng prevState
handleOpenActions () {
	this.setState((prevState) => ({ isOpenNoteAction: !prevState.isOpenNoteAction}))
}

2. TypeError: this.setState is not a function

_ Nhớ bind(this) hàm trong constructor

3. Sử dụng map

+ enables you to iterate over your list of items to display them
+ convert one list of items to another list of items. Ex: convert a list of item to HTML elements.
+ add key attribute to list item. Only that way React is able to identify added, changed and removed items when the
list changes.
+ You should make sure that the key attribute is a stable identifier. Don’t make the mistake of using the item index 
in the array. The array index isn’t stable at all.

// Do this
{list.map(function (item) {
    return (
		<div key={item.objectID}> // add key attribute to list item
		  <span>
			<a href={item.url}>{item.title}</a>
		  </span>
		  <span>{item.author}</span>
		  <span>{item.num_comments}</span>
		  <span>{item.points}</span>
		</div>
	)
})}

// Don't do this
{ list.map(function(item, key) {
	return (
		<div key={key}>
		...
		</div>
	);
})}

4. Sử dụng arrow function

// function expression
function () { ... }

// arrow function expression
() => { ... }

+ You can remove the parenthesis when the function gets only one argument
// allowed
item => { ... }

// allowed
(item) => { ... }

// not allowed
item, key => { ... }

// allowed
(item, key) => { ... }

{list.map(function (item) {
    return (
		<div key={item.objectID}>
		
{list.map(item => {
	return (
		<div key={item.objectID}>
		...
	)}}
	
_ Can remove block body and return statement.  In a concise body an implicit
return is attached thus you can remove the return statement

{list.map(item =>
		<div key={item.objectID}>
		...
	)}}
	
5. ES6 const and let

_ A variable declared with 'const' cannot be re-assigned or re-declared. It cannot get mutated (changed, modifield)

const hello = 'ReactJS'
hello = 'bye bye' > Uncaught TypeError: Assignment to constant variable.

_ A variable declared with let can get mutated.

let abc = 'React Native'
abc = 'Flutter' > Flutter

Note: When the variable is an array or object, the value it holds can get altered.

const example = {
    text: 'Welcome to React'
}

example.text > "Welcome to React"
example.text = 'Say hi'
example.text > "Say hi"

_ In your application, you should use const over var.

6. ReactDOM

ReactDOM.render(
	<App />,
	document.getElementById('root')
);

_ ReactDOM.render() uses a DOM node in your HTML to replace it with your JSX.
_ ReactDOM.render() expects two arguments:
+ The first argument is JSX that gets rendered.
+  The second argument specifies the place where the React application hooks into your HTML.
It expects an element with an id='root'. 

7. Key and variable share the same name

this.state = {
	list: list
}

this.state = {
	list
}

8. Bind(this)

// the function is bound to the class => becomes a class method
this.onDismiss = this.onDismiss.bind(this)

9. DESTRUCTING

_ Object
const { searchTerm, list } = this.state

_ Array
const users = ['Robin', 'Andrew', 'Dan'];
const [
	userOne,
	userTwo,
	userThree
] = users;
console.log(userOne, userTwo, userThree);
// output: Robin Andrew Dan

10. CONDITION

+ 1st

result ? <Table /> : null

result && <Table />

11. ES6 CLASSES

+ Even though React embraces functional programming, for instance with immutable data structures,
classes are used to declare components. They are called ES6 class components. 

class Developer {
	constructor(firstname, lastname) {
		this.firstname = firstname;
		this.lastname = lastname;
	}
	getName() {
		return this.firstname + ' ' + this.lastname;
	}
}

+ A class has a constructor to make it instantiable. The constructor can take arguments to assign it to
the class instance. Additionally a class can define functions. 
+  Because the function is associated with a class, it is called a method.
+ You can create multiple instances of the class by invoking it

_ Extends 'Component':

import React, { Component } from 'react';
...
class App extends Component {
	render() {
	...
	}
}

+ 'App' inherits functionalities from the Component class, extend a basic ES6 class to a ES6 component class.
+ The methods a React Component exposes is the public interface. One of these methods has to be overwritten,
the others don’t need to be overwritten.

12. INTERNAL COMPONENT STATE

+ Internal component state allows you to store, modify and delete properties of your component.
+  The ES6 class component can use a constructor to initialize internal component state. The constructor is
called only once when the component initializes.

class App extends Component {
	constructor(props) {
		super(props);
		
		this.state = {
			list: list,
		};
	}
	...
}

+ Note that you have to call super(props); to call the constructor of the extended Component class.
It’s mandatory, because it sets this.props in your constructor.
+ The state is bound to the class with the this object.
+ Every time you change your component state, the render() method of your component will run again.

NOTE:  Don’t mutate the state directly. You have to use a method called setState() to modify your state.

13. ES6 OBJECT INITIALIZER

+ You can initialize methods in an object

// ES6
const userService = {
	getUserName(user) {
		return user.firstname + ' ' + user.lastname;
	},
};

14. FILTER

+ The filter function takes a function to evaluate each item in the list. 
If the evaluation for an item is true, the item stays in the list. Otherwise it will get removed. 
Additionally the function returns a new list and doesn’t mutate the old list.

Example:

var ages = [32, 33, 16, 40];

function checkAdult(age) {
  return age >= 18;
}

function myFunction() {
  document.getElementById("demo").innerHTML = ages.filter(checkAdult);
}

>>> 32,33,40

15. HIGH ORDER FUNCTION

+ We have to pass the searchTerm to the filter function and have to return a new function to evaluate the
condition. That’s called a higher order function

list.filter(isSearched(searchTerm))

function isSearched(searchTerm) {
	return function(item) {
		return !searchTerm || // You filter the list only when a searchTerm is set, else return all list
			item.title.toLowerCase().includes(searchTerm.toLowerCase());
	}
}

16. PROPS

+ The props - short form for properties - have all the values you have passed to the components when
you used them in your App component. You could reuse these components somewhere else but pass them different values.
They are reusable.

+  After all it is not only text that you can pass as children. You can pass an element and element trees 
(which can be encapsulated by components again) as children.

17. DEFAULT PARAMETER

class Button extends Component {
	render() {
		const {
			onClick,
			className = '',
			children,
		} = this.props;
		...
	}
}

Now, whenever there is no className property, the value will be an empty string.

18. COMPONENT DECLARATIONS

_ Functional Stateless Components: 
+ Which get an input and return an output. The input is the props object.
The output is a component instance.
+ Functional stateless components are functions (functional) and they have no internal state (stateless)
+ Additionally they have no lifecycle methods.

_ ES6 Class Components:
+ They extend from the React component. The extend hooks all the lifecycle methods
- available in the React component API - to the component. 
+ You can store and manipulate state in ES6 class components

Ex:
function Search({ value, onChange, children }) {
	return (
		<form>
			{children} <input
				type="text"
				value={value}
				onChange={onChange}
			/>
		</form>
	);
}

const Search = ({ value, onChange, children }) =>
	<form>
	{children} <input
		type="text"
		value={value}
		onChange={onChange}
		/>
	</form>



